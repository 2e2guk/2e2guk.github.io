---
title: "ITMO-DSU-1B"
excerpt: "ì½”ë“œí¬ìŠ¤ ITMO academy pilot course DSU step1 Bë²ˆ"

categories:
  - Datestructure
tags:
  - [tag1, tag2]

permalink: /Datastructure/ITMO-DSU-1B/

toc: true
toc_sticky: true
use_math : true

date: 2024-08-04
last_modified_at: 2024-08-04
---

## ğŸ¦¥ ë³¸ë¬¸

### ë¬¸ì œ ë§í¬

[ITMO-DSU-1B](https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/B)

### í’€ì´ ì‹œê°„

ìƒëµ

### ë¬¸ì œ ì„¤ëª…

ë‹¤ìŒ ë‘ ê°€ì§€ ì—°ì‚°ì„ ì§€ì›í•˜ëŠ” DSU ìë£Œêµ¬ì¡°ë¥¼ ì„¤ê³„í•˜ë¼. 

1. union x y : x, yì›ì†Œë¥¼ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹˜ê¸°
2. get x = xê°€ ì†í•œ ì§‘í•©ì„ ì°¾ê³ , ê·¸ ì§‘í•©ì˜ {ìµœì†Œ ì›ì†Œ, ìµœëŒ€ ì›ì†Œ, ì›ì†Œì˜ ê°œìˆ˜} ë¥¼ ë°˜í™˜


### ë¬¸ì œ í’€ì´

DSU ì‘ìš© ë¬¸ì œì´ë‹¤. 

DSUëŠ”, **ê²°í•©ë²•ì¹™ê³¼ êµí™˜ë²•ì¹™ì´ ì„±ë¦½í•˜ëŠ” ëª¨ë“  ì—°ì‚°ì„ ì§€ì›**í•  ìˆ˜ ìˆë‹¤. ê³ ë¡œ ì´ ë¬¸ì œì—ì„œì˜ ìµœì†Œ, ìµœëŒ€ êµ¬ê°„ í•© ëª¨ë‘ ì§€ì›ì´ ê°€ëŠ¥í•˜ë‹¤

get ì—°ì‚°ì˜ êµ¬í˜„ì´ ê´€ê±´ì¸ë°, ì²˜ìŒì— DSUë¥¼ ì´ˆê¸°í™”í•  ë•Œ, **ìµœì†Ÿê°’, ìµœëŒ“ê°’, êµ¬ê°„ì˜ í•©** ì„ êµ¬í•˜ëŠ” ë°°ì—´ì„ ì„ ì–¸í•˜ê³ , ì´ˆê¸°í™”ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì§„í–‰í•œë‹¤. 

1. ìµœì†Ÿê°’ : ì´ˆê¸°í™”ì‹œ parentë°°ì—´ê³¼ ê°™ì´, ìê¸° ìì‹ ìœ¼ë¡œ ì´ˆê¸°í™”
2. ìµœëŒ“ê°’ : ì´ˆê¸°í™”ì‹œ parentë°°ì—´ê³¼ ê°™ì´, ìê¸° ìì‹ ìœ¼ë¡œ ì´ˆê¸°í™”
3. êµ¬ê°„í•© : ì´ˆê¸°í™”ì‹œ, ëª¨ë‘ 1ë¡œ ì´ˆê¸°í™”.

êµ¬ê°„í•© ë°°ì—´ì€ ì–´ë””ì— ì“°ëŠ”ê°€ í•˜ë©´, ëª¨ë‘ 1ë¡œ ì´ˆê¸°í™”í•˜ê³ , í•©ì¹  ë•Œë§ˆë‹¤, í•©ì¹¨ ë‹¹í•˜ëŠ” ìª½ì˜ êµ¬ê°„í•©ì—, í•©ì³ì§€ëŠ” ìª½ì˜ êµ¬ê°„í•©ì„ ëˆ„ì ì‹œí‚¨ë‹¤. ì´ˆê¸°ì— 1ë¡œ ì´ˆê¸°í™”í•¨ìœ¼ë¡œì¨, 

ê° ì¡í•©ì—ëŠ” 1ê°œì˜ ì›ì†Œê°€ ë“¤ì–´ ìˆëŠ” ìƒí™©ì„ ë‚˜íƒ€ë‚´ê³ , ëˆ„ì ì‹œí‚¤ëŠ” ê²ƒìœ¼ë¡œ, ì„œë¡œì˜ ì›ì†Œì˜ ê°œìˆ˜ë¥¼ ë”í•´ì„œ í•©ì¹¨ ë‹¹í•˜ëŠ” ìª½ìœ¼ë¡œ ë„£ì–´ì¤€ë‹¤. 

êµ¬í˜„ëœ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. 

```cpp
// ITMO DSU step 1, B
// https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/B
#include <bits/stdc++.h>
using namespace std;
#define MAX 300000

template <typename IndexType>
struct DSU {
    vector<IndexType> parent, rank;
    vector<IndexType> sum, minimum, maximum;
    DSU(IndexType n) : parent(n), rank(n, 1), sum(n, 1), minimum(n), maximum(n) {
        for(IndexType i = 0; i < n; i++) {
            parent[i] = i;
            minimum[i] = i; maximum[i] = i;
        }
    }

    // ì„ì˜ì˜ ì›ì†Œ uê°€ ì†í•œ root ë²ˆí˜¸ ë°˜í™˜
    // ê²½ë¡œ ì••ì¶•
    IndexType find(IndexType u) {
        if(u == parent[u]) return u;
        return parent[u] = find(parent[u]);
    }

    // uê°€ ì†í•œ ì§‘í•©ì„, vê°€ ì†í•œ ì§‘í•©ìœ¼ë¡œ ë³‘í•©
    // union by rank
    void merge(IndexType u, IndexType v) {
        u = find(u); v = find(v);
        if(u == v) return;
        if(rank[u] > rank[v]) swap(u, v);
        sum[v] += sum[u];
        minimum[v] = min(minimum[u], minimum[v]);
        maximum[v] = max(maximum[u], maximum[v]);
        parent[u] = v;
        if(rank[u] == rank[v]) ++rank[v];
    }

    tuple<IndexType, IndexType, IndexType> Get(IndexType u) {
        IndexType root = find(u);
        return {minimum[root], maximum[root], sum[root]};
    }
};

int main() {
    ios_base::sync_with_stdio(false); cin.tie(nullptr);
    int n, m; cin >> n >> m;
    DSU<int> dsu(n);
    string op; int x, y;
    tuple<int, int, int> res;
    while(m--) {
        cin >> op;
        if(op == "union") {
            cin >> x >> y; x--; y--;
            dsu.merge(x, y);
        } else {
            cin >> x; x--;
            res = dsu.Get(x);
            // 0-based -> 1-based
            cout << get<0>(res) + 1 << " " << get<1>(res) + 1 << " " << get<2>(res);
        }
        cout << "\n";
    }
    return 0;
}
```

ë§ˆì§€ë§‰ ì¶œë ¥ë¶€ì—ì„œ, ë¬¸ì œì—ì„œëŠ” 1-based index ë¡œ ì£¼ì–´ì¡Œìœ¼ë¯€ë¡œ, ë‹¤ì‹œ 0-basedì—ì„œ 1-basedë¡œ ëŒë ¤ ë†“ì•„ì•¼ í•œë‹¤. 

### ì´í‰

DSU ì‘ìš© ë¬¸ì œì˜€ë‹¤. ì œì¶œ ì½”ë“œëŠ” 234msì— ACë¥¼ ë°›ëŠ”ë‹¤. 

<img width="875" alt="ìŠ¤í¬ë¦°ìƒ· 2024-08-04 ì˜¤í›„ 5 41 08" src="https://github.com/user-attachments/assets/ebed5374-74e7-48c5-9c62-18a2ed5ed588">













