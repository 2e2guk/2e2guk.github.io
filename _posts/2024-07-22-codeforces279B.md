---
title: "codeforces-279B"
excerpt: "ì½”ë“œí¬ìŠ¤ 279Bë¬¸ì œ í•´ê²°"

categories:
  - two-pointers
tags:
  - [tag1, tag2]

permalink: /two-pointers/codeforces-279B/

toc: true
toc_sticky: true

date: 2024-07-22
last_modified_at: 2024-07-22
---

## ğŸ¦¥ ë³¸ë¬¸

### ë¬¸ì œ ë§í¬ 

[codeforces 279B](https://codeforces.com/problemset/problem/279/B)

### í’€ì´ ì‹œê°„

ì•„ì´ë””ì–´ : -3:55t(TLE, ë‹¤ë¥¸ ì‚¬ëŒ ì½”ë“œ ë³´ê³  í•™ìŠµ) + êµ¬í˜„ -9:16t = -13:21t

### ë¬¸ì œ ì„¤ëª…

#### TLEë¥¼ ë°›ì•˜ë˜ ì²« ë²ˆì§¸ ì ‘ê·¼

TLEë¥¼ ë°›ì•˜ë˜ ë¬¸ì œ. ì²˜ìŒ ë³´ê³  ë°”ë¡œ ë“  ìƒê°ì€, êµ¬ê°„ í•©ì„ ê´€ë¦¬í•˜ê¸°ì— **Segment Tree** ê°€ ë°”ë¡œ ìƒê°ë‚¬ì—ˆë‹¤. 

ê·¸ë˜ì„œ, ëª¨ë“  iì— ëŒ€í•´ì„œ, ëª¨ë“  ê°€ëŠ¥í•œ ê²½ìš°ë¥¼ íƒìƒ‰í•˜ê³ ì í•˜ì˜€ìœ¼ë‚˜, ì´ ë°©ë²•ì€, ë‚ ë¦¬ëŠ” ì¿¼ë¦¬ì˜ ê°œìˆ˜ê°€ **n^2** ê°œì¸ ë§Œí¼, 

ì‹œê°„ ë³µì¡ë„ê°€ **O(N^2logN)** ì´ ë˜ì–´ì„œ, N <= 10^5 ì¸ ì´ ë¬¸ì œì—ì„œëŠ” TLEë¥¼ ë°›ì„ ìˆ˜ ë°–ì— ì—†ì—ˆë‹¤. 

ë¨¼ì €, TLEë¥¼ ë°›ì€ ì½”ë“œë¥¼ ì²¨ë¶€í•œë‹¤. 

```cpp
// codeforces 297B
// https://codeforces.com/problemset/problem/279/B
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

template<typename ValueType, typename IndexType>
struct Seg {
    vector<ValueType> segmentTree;
    vector<ValueType> array;
    IndexType n;

    Seg(const vector<ValueType>& inputArray) {
        n = inputArray.size();
        array = inputArray;
        IndexType treeDepth = ceil(log2(n));
        IndexType treeSize = 1 << (treeDepth + 1);
        segmentTree.resize(treeSize);
        makeSegmentTree(1, 0, n - 1);
    }

    ValueType makeSegmentTree(IndexType node, IndexType start, IndexType end) {
        if (start == end) {
            return segmentTree[node] = array[start];
        }
        IndexType mid = (start + end) / 2;
        return segmentTree[node] = makeSegmentTree(node * 2, start, mid) + makeSegmentTree(node * 2 + 1, mid + 1, end);
    }

    // ì¸ë±ìŠ¤ idxì˜ ê°’ì„, diffë§Œí¼ ì—…ë°ì´íŠ¸í•œë‹¤. 
    void updateSegmentTree(IndexType node, IndexType start, IndexType end, IndexType idx, ValueType diff) {
        if (idx < start || idx > end) return;
        segmentTree[node] += diff;
        if (start != end) {
            IndexType mid = (start + end) / 2;
            updateSegmentTree(node * 2, start, mid, idx, diff);
            updateSegmentTree(node * 2 + 1, mid + 1, end, idx, diff);
        }
    }

    ValueType sumSegmentTree(IndexType node, IndexType left, IndexType right, IndexType start, IndexType end) {
        if (left > end || right < start) return 0;
        if (left <= start && right >= end) return segmentTree[node];
        IndexType mid = (start + end) / 2;
        return sumSegmentTree(node * 2, left, right, start, mid) + sumSegmentTree(node * 2 + 1, left, right, mid + 1, end);
    }

    void update(IndexType idx, ValueType newValue) {
        ValueType diff = newValue - array[idx];
        array[idx] = newValue;
        updateSegmentTree(1, 0, n - 1, idx, diff);
    }

    ValueType query(IndexType left, IndexType right) {
        return sumSegmentTree(1, left, right, 0, n - 1);
    }
};

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int n, t; cin >> n >> t;

    vector<ll> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];

    Seg<ll, ll> segTree(arr);

    vector<ll> temp;
    vector<ll> res;

    for (int i = 0; i < n; i++) {
        temp.clear();
        for(int j = i; j < n; j++) {
            if(segTree.query(i, j) <= t) temp.push_back(j - i + 1);
            else {
                if(temp.empty()) temp.push_back(0);
                else break;
            };
        }
        res.push_back(temp.back());
    }
    cout << *max_element(res.begin(), res.end());
    return 0;
}
```
#### ì˜¬ë°”ë¥¸ ì ‘ê·¼ ë°©ì‹

ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì˜¬ë°”ë¥¸ ì ‘ê·¼ ë°©ì‹ì€, **íˆ¬ í¬ì¸í„°, ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê¸°ë²•** ì„ ì´ìš©í•˜ëŠ” ê²ƒì´ë‹¤. 

ê·¸ëƒ¥, start, end êµ¬ê°„ì„ ì •í•´ë‘ê³ , ë¬´ì¡°ê±´ ì²« ë²ˆì§¸ ì±…ë¶€í„° ì½ëŠ”ë‹¤. ê·¸ëŸ¬ë‹¤ê°€, 

ë§Œì•½ t ì‹œê°„ì„ ì´ˆê³¼í•˜ê²Œ ë˜ë©´, start ìœ„ì¹˜ì— í•´ë‹¹í•˜ëŠ” ì±…ì„ ì½ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ë§Œí¼ì„ ë¹¼ ì£¼ê³ , start ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚¨ë‹¤. 

ê·¸ë¦¬ê³ , í˜„ì¬ê¹Œì§€ ì½ì€ ê°€ì¥ ë§ì€ ì±…ì˜ ê°œìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” max_books_readë¥¼ ì—…ë°ì´íŠ¸í•œë‹¤.

```cpp
max_books_read = max(max_books_read, end - start + 1);
```

ê·¸ë¦¬ê³ , end ìœ„ì¹˜ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚¨ë‹¤. ì´ëŠ” ì±…ì„ í•œê¶Œ ë” ì½ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚¸ë‹¤. 

ì´ë ‡ê²Œ í•˜ë©´, ê¸°ì¡´ì˜ O(N^2logN) ì—ì„œ, **O(N)** ìœ¼ë¡œ ì‹œê°„ ë³µì¡ë„ë¥¼ íšê¸°ì ìœ¼ë¡œ ì¤„ì¼ ìˆ˜ ìˆë‹¤. 

ì™„ì„±ëœ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```cpp
// codeforces 297B
// https://codeforces.com/problemset/problem/279/B
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int n, t;
    cin >> n >> t;
    vector<int> books(n);
    
    for (int i = 0; i < n; ++i) cin >> books[i];
    
    int start = 0, end = 0, current_sum = 0, max_books_read = 0;
    
    while (end < n) {
        // í˜„ì¬ ì±…ì„ ì½ëŠ” ë° í•„ìš”í•œ ì‹œê°„ì„ ë”í•¨
        current_sum += books[end];
        
        // ë§Œì•½ í˜„ì¬ í•©ì´ të¥¼ ì´ˆê³¼í•˜ë©´ start í¬ì¸í„°ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚´
        while (current_sum > t) {
            current_sum -= books[start];
            start++;
        }
        
        // ìµœëŒ€ ì½ì„ ìˆ˜ ìˆëŠ” ì±…ì˜ ìˆ˜ë¥¼ ì—…ë°ì´íŠ¸
        max_books_read = max(max_books_read, end - start + 1);
        
        // end í¬ì¸í„°ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚´
        end++;
    }
    
    cout << max_books_read << '\n';
    
    return 0;
}
```

### ì´í‰

ë„ˆë¬´ ì–´ë µê²Œ ìƒê°í•˜ì§€ ì•Šì•˜ìœ¼ë©´ í•œë‹¤. ê·¸ë¦¬ê³ , 20ë¶„ íƒ€ì„ì–´íƒ ë•Œë¬¸ì¸ì§€, ì‹œê°„ ë³µì¡ë„ë¥¼ ë³„ë¡œ ìƒê°í•˜ì§€ ì•Šìœ¼ë ¤ëŠ” ê²ƒ ê°™ì•„ì„œ, ì´ ë¶€ë¶„ì€ ìˆ˜ì •ì´ í•„ìš”í•œ ê²ƒ ê°™ë‹¤. 






