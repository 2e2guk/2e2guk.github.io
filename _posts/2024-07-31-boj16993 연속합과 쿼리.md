---
title: "boj16993 ì—°ì†í•©ê³¼ ì¿¼ë¦¬"
excerpt: "boj16993 ì—°ì†í•©ê³¼ ì¿¼ë¦¬ ë¬¸ì œ í’€ì´"

categories:
  - range-query
tags:
  - [tag1, tag2]

permalink: /range-query/boj16993 ì—°ì†í•©ê³¼ ì¿¼ë¦¬/

toc: true
toc_sticky: true
use_math : true

date: 2024-07-31
last_modified_at: 2024-07-31
---

## ğŸ¦¥ ë³¸ë¬¸

### ë¬¸ì œ ë§í¬

[boj 16993](https://www.acmicpc.net/problem/16993)

### í’€ì´ ì‹œê°„

ìƒëµ

### ë¬¸ì œ ì„¤ëª…

ë¬¸ì œê°€ ì§§ìœ¼ë‹ˆ, ë¬¸ì œë¥¼ ê·¸ëŒ€ë¡œ ì²¨ë¶€í•œë‹¤. 

ê¸¸ì´ê°€ Nì¸ ìˆ˜ì—´ A1, A2, ..., ANì´ ì£¼ì–´ì§„ë‹¤. ì´ë•Œ, ë‹¤ìŒ ì¿¼ë¦¬ë¥¼ ìˆ˜í–‰í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

i j : Ai, Ai+1, ..., Ajì—ì„œ ê°€ì¥ í° ì—°ì†í•©ì„ ì¶œë ¥í•œë‹¤. (1 â‰¤ i â‰¤ j â‰¤ N)

ìˆ˜ì—´ì˜ ì¸ë±ìŠ¤ëŠ” 1ë¶€í„° ì‹œì‘í•œë‹¤.

ì—°ì†í•©ì€ ì—°ì†ëœ ëª‡ ê°œì˜ ìˆ˜ë¥¼ ì„ íƒí•´ì„œ êµ¬í•  ìˆ˜ ìˆëŠ” í•© ì¤‘ ê°€ì¥ í° í•©ì´ë©°, ìˆ˜ëŠ” í•œ ê°œ ì´ìƒ ì„ íƒí•´ì•¼ í•œë‹¤.

### ë¬¸ì œ í’€ì´

[ê¸ˆê´‘ ì„¸ê·¸](https://2e2guk.github.io/range-query/ê¸ˆê´‘%20ì„¸ê·¸/) ë¥¼ ì´ìš©í•´ í‘¸ëŠ” ê¸°ë³¸ ë¬¸ì œì´ë‹¤. ê¸ˆê´‘ ì„¸ê·¸ êµ¬í˜„ í™•ì¸ ë° ì—°ìŠµ ë¬¸ì œ ìš©ë„ì¸ ê²ƒ ê°™ë‹¤. 

ì™„ì„±ëœ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. 

```cpp
// boj 16993 ì—°ì†í•©ê³¼ ì¿¼ë¦¬
// ê¸ˆê´‘ ì„¸ê·¸
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

template <typename ValueType, typename IndexType>
struct GoldenSeg {
    vector<ValueType> arr, pref, suff, ans, sum;
    ValueType n;

    GoldenSeg(const vector<ValueType>& input) {
        n = input.size();
        arr = input;
        pref = sum = ans = suff = vector<ValueType>(n * 4);
        build(1, 0, n - 1);
    }

    void build(IndexType i, IndexType tl, IndexType tr) {
        if (tl == tr) {
            suff[i] = ans[i] = pref[i] = arr[tl];
            sum[i] = arr[tl];
        } else {
            IndexType tm = (tl + tr) / 2;
            build(i * 2, tl, tm);
            build(i * 2 + 1, tm + 1, tr);
            ans[i] = max(ans[i * 2], max(ans[i * 2 + 1], suff[i * 2] + pref[i * 2 + 1]));
            pref[i] = max(pref[i * 2], sum[i * 2] + pref[i * 2 + 1]);
            suff[i] = max(suff[i * 2 + 1], sum[i * 2 + 1] + suff[i * 2]);
            sum[i] = sum[i * 2] + sum[i * 2 + 1];
        }
    }

    void update(IndexType i, IndexType tl, IndexType tr, IndexType p) {
        if (tl == tr) {
            suff[i] = ans[i] = pref[i] = arr[tl];
            sum[i] = arr[tl];
        } else {
            IndexType tm = (tl + tr) / 2;
            if (tm >= p) update(i * 2, tl, tm, p);
            else update(i * 2 + 1, tm + 1, tr, p);
            
            ans[i] = max(ans[i * 2], max(ans[i * 2 + 1], suff[i * 2] + pref[i * 2 + 1]));
            pref[i] = max(pref[i * 2], sum[i * 2] + pref[i * 2 + 1]);
            suff[i] = max(suff[i * 2 + 1], sum[i * 2 + 1] + suff[i * 2]);
            sum[i] = sum[i * 2] + sum[i * 2 + 1];
        }
    }

    void update(IndexType idx, ValueType val) {
        arr[idx] = val;
        update(1, 0, n - 1, idx);
    }
    struct Result {
        ValueType ans, pref, suff, sum;
    };

    Result merge(const Result &left, const Result &right) {
        Result res;
        res.ans = max({left.ans, right.ans, left.suff + right.pref});
        res.pref = max(left.pref, left.sum + right.pref);
        res.suff = max(right.suff, right.sum + left.suff);
        res.sum = left.sum + right.sum;
        return res;
    }

    Result query(IndexType i, IndexType tl, IndexType tr, IndexType l, IndexType r) {
        if (l > r) {
            return {numeric_limits<IndexType>::min(), numeric_limits<IndexType>::min(), numeric_limits<IndexType>::min(), 0};
        }
        if (tl == l && tr == r) {
            return {ans[i], pref[i], suff[i], sum[i]};
        }
        IndexType tm = (tl + tr) / 2;
        return merge(query(i * 2, tl, tm, l, min(r, tm)),
                     query(i * 2 + 1, tm + 1, tr, max(l, tm + 1), r));
    }
    Result query(IndexType l, IndexType r) {
        return query(1, 0, n - 1, l, r);
    }
};

int main() {
    ios_base::sync_with_stdio(false); cin.tie(nullptr);
    ll n; cin >> n;
    vector<ll> input(n);
    for (auto &x : input) cin >> x;

    GoldenSeg<ll, int> segTree(input);

    int m; cin >> m;

    while (m--) {
        // range input, 1-based indexing -> 0-based indexing
        ll x, y; cin >> x >> y;
        cout << segTree.query(x - 1, y - 1).ans << "\n";
    }
    return 0;
}
```

[ì´ ë¬¸ì œ](https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A) ì™€ëŠ” ë‹¤ë¥´ê²Œ, 

êµ¬í•œ ë¶€ë¶„ ë°°ì—´ì˜ í•©ì˜ ìµœëŒ“ê°’ì´ ìŒìˆ˜ë”ë¼ê³  ê·¸ëŒ€ë¡œ ë‚´ë³´ë‚´ì•¼ í•˜ê¸° ë•Œë¬¸ì—, 

ans, pref, suff ë¥¼ ì´ˆê¸°í™”í•˜ëŠ” ë¶€ë¶„ì—ì„œ, arr[tl] ê°’ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•œë‹¤. 

### ì´í‰

[ê¸ˆê´‘ ì„¸ê·¸](https://2e2guk.github.io/range-query/ê¸ˆê´‘%20ì„¸ê·¸/) ê¸°ë³¸ ë¬¸ì œì´ë‹¤. 

[ì œì¶œ ì •ë³´](https://www.acmicpc.net/source/81861840)



